/*
 * Global game manager that prevents multiple instances from running
 */

import { Chess } from 'chess.js';

class GameManager {
  constructor() {
    this.instanceId = Math.random().toString(36).substring(2, 8);
    
    // Prevent multiple instances from running game loops
    if (global.gameManagerExists) {
      console.log(`Instance ${this.instanceId} blocked - another instance already running`);
      this.isBlocked = true;
      return;
    }
    
    global.gameManagerExists = true;
    this.isBlocked = false;
    
    this.game = new Chess();
    this.gptWins = 0;
    this.claudeWins = 0;
    this.gameId = 1;
    this.gameStatus = 'Starting...';
    this.currentPlayer = '';
    this.viewers = 0;
    this.isRunning = false;
    this.moveInProgress = false;
    this.moveHistory = [];
    
    console.log(`GameManager instance ${this.instanceId} created and running`);
    
    // Start the game loop
    this.startGameLoop();
  }

  getGameState() {
    if (this.isBlocked) {
      return {
        fen: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
        gptWins: 0,
        claudeWins: 0,
        gameId: 1,
        gameStatus: 'Instance blocked',
        currentPlayer: '',
        viewers: 0,
        moveHistory: [],
        instanceId: this.instanceId
      };
    }

    return {
      fen: this.game.fen(),
      gptWins: this.gptWins,
      claudeWins: this.claudeWins,
      gameId: this.gameId,
      gameStatus: this.gameStatus,
      currentPlayer: this.currentPlayer,
      viewers: this.viewers,
      moveHistory: this.moveHistory,
      instanceId: this.instanceId
    };
  }

  addViewer() {
    if (this.isBlocked) return;
    this.viewers++;
    console.log(`Instance ${this.instanceId}: ${this.viewers} viewers`);
  }

  removeViewer() {
    if (this.isBlocked) return;
    this.viewers = Math.max(0, this.viewers - 1);
    console.log(`Instance ${this.instanceId}: ${this.viewers} viewers`);
  }

  // Reset game state completely
  resetGame() {
    if (this.isBlocked) return;
    this.game = new Chess();
    this.moveHistory = [];
    this.currentPlayer = '';
    this.moveInProgress = false;
    console.log(`Instance ${this.instanceId}: Game ${this.gameId} reset - Fresh board: ${this.game.fen()}`);
  }

  async requestMove(ai) {
    if (this.isBlocked) return undefined;
    
    try {
      const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/move`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          fen: this.game.fen(), 
          ai 
        }),
      });
      
      if (!response.ok) {
        console.error(`Instance ${this.instanceId}: AI API call failed for ${ai}:`, response.status);
        return undefined;
      }
      
      const data = await response.json();
      return typeof data.move === 'string' ? data.move.trim() : undefined;
    } catch (error) {
      console.error(`Instance ${this.instanceId}: Error calling AI API for ${ai}:`, error);
      return undefined;
    }
  }

  applyAIMove(moveUci, playerName) {
    if (this.isBlocked) return false;
    
    if (!this.game || typeof this.game.moves !== 'function') {
      console.error(`Instance ${this.instanceId}: Invalid game object`);
      return false;
    }

    const moves = this.game.moves({ verbose: true });
    if (moves.length === 0) {
      console.log(`Instance ${this.instanceId}: No legal moves available`);
      return false;
    }

    // Try to apply the AI's move
    const candidate = (typeof moveUci === 'string' && moveUci.length >= 4)
      ? {
          from: moveUci.slice(0, 2),
          to: moveUci.slice(2, 4),
          promotion: moveUci.length === 5 ? moveUci[4] : undefined,
        }
      : null;

    try {
      if (candidate) {
        const move = this.game.move(candidate);
        if (move) {
          this.moveHistory.push(move.san);
          console.log(`Instance ${this.instanceId}: ${playerName} played: ${moveUci} (${move.san}) - Game ${this.gameId}`);
          return true;
        }
      }
    } catch (err) {
      console.log(`Instance ${this.instanceId}: ${playerName}'s move ${moveUci} was invalid:`, err.message);
    }

    // Fallback to random move
    const randomMove = moves[Math.floor(Math.random() * moves.length)];
    try {
      const move = this.game.move(randomMove.san);
      this.moveHistory.push(move.san);
      console.log(`Instance ${this.instanceId}: ${playerName} fallback to random move: ${move.san} - Game ${this.gameId}`);
      return true;
    } catch (err) {
      console.error(`Instance ${this.instanceId}: Failed to apply fallback move: ${err.message}`);
      return false;
    }
  }

  async startGameLoop() {
    if (this.isBlocked) {
      console.log(`Instance ${this.instanceId}: Blocked from starting game loop`);
      return;
    }
    
    if (this.isRunning) {
      console.log(`Instance ${this.instanceId}: Game loop already running`);
      return;
    }
    this.isRunning = true;
    
    console.log(`Instance ${this.instanceId}: Starting global game loop...`);

    while (this.isRunning) {
      try {
        console.log(`Instance ${this.instanceId}: === Starting Game ${this.gameId} ===`);
        
        // Completely reset game state
        this.resetGame();
        this.gameStatus = `Game ${this.gameId} in progress`;
        this.currentPlayer = 'GPT (White)';
        
        // Brief pause to let state propagate
        await this.sleep(2000);
        
        // Play the game
        while (!this.game.isGameOver() && this.isRunning) {
          // GPT move (White)
          if (this.game.turn() === 'w') {
            this.currentPlayer = 'GPT (White)';
            this.moveInProgress = true;
            
            const gptMove = await this.requestMove('gpt');
            if (!this.applyAIMove(gptMove, 'GPT')) {
              console.log(`Instance ${this.instanceId}: GPT failed to make a move, ending game`);
              break;
            }
            
            this.moveInProgress = false;
            await this.sleep(3000);
          }
          
          if (this.game.isGameOver()) break;

          // Claude move (Black)
          if (this.game.turn() === 'b') {
            this.currentPlayer = 'Claude (Black)';
            this.moveInProgress = true;
            
            const claudeMove = await this.requestMove('claude');
            if (!this.applyAIMove(claudeMove, 'Claude')) {
              console.log(`Instance ${this.instanceId}: Claude failed to make a move, ending game`);
              break;
            }
            
            this.moveInProgress = false;
            await this.sleep(3000);
          }
        }

        // FIXED: Determine winner correctly
        let winner = '';
        if (this.game.isCheckmate()) {
          // When checkmate occurs, game.turn() returns the player who CANNOT move (the loser)
          // So if it's white's turn and checkmate, white lost (Claude wins)
          // If it's black's turn and checkmate, black lost (GPT wins)
          winner = this.game.turn() === 'w' ? 'claude' : 'gpt';
          this.gameStatus = `Game ${this.gameId} finished - ${winner === 'gpt' ? 'GPT' : 'Claude'} wins by checkmate!`;
        } else if (this.game.isStalemate()) {
          this.gameStatus = `Game ${this.gameId} finished - Stalemate (Draw)`;
        } else if (this.game.isDraw()) {
          this.gameStatus = `Game ${this.gameId} finished - Draw`;
        } else {
          this.gameStatus = `Game ${this.gameId} ended`;
        }

        // Update win counters
        if (winner === 'gpt') {
          this.gptWins++;
          console.log(`Instance ${this.instanceId}: GPT wins! Score now GPT: ${this.gptWins}, Claude: ${this.claudeWins}`);
        } else if (winner === 'claude') {
          this.claudeWins++;
          console.log(`Instance ${this.instanceId}: Claude wins! Score now GPT: ${this.gptWins}, Claude: ${this.claudeWins}`);
        }

        this.currentPlayer = '';
        console.log(`Instance ${this.instanceId}: Game ${this.gameId} finished: ${this.gameStatus}`);

        // Wait before next game and increment game ID
        await this.sleep(8000);
        this.gameId++;
        
      } catch (error) {
        console.error(`Instance ${this.instanceId}: Error in game loop:`, error);
        this.gameStatus = `Error occurred, restarting... (Instance ${this.instanceId})`;
        await this.sleep(5000);
      }
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  stop() {
    if (this.isBlocked) return;
    this.isRunning = false;
    console.log(`Instance ${this.instanceId}: Game loop stopped`);
    
    // Release the global lock when stopping
    delete global.gameManagerExists;
  }
}

// Global singleton instance
let gameManager = null;

export function getGameManager() {
  if (!gameManager) {
    gameManager = new GameManager();
  }
  return gameManager;
}

// Initialize on first import
if (typeof window === 'undefined') {
  // Only run on server
  getGameManager();
}
